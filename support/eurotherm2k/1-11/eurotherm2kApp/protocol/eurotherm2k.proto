## \file
## Stream Device Protocol for eurotherm 2000 series EI Bisynch
## \param GAD = First char of address, e.g. address = 1, GAD = 0, address = 12, GAD = 1
## \param LAD = Second char of address, e.g. address = 1, LAD = 1, address = 12, LAD = 2

locktimeout = 5000;

## Unfortunately, this is designed with a checksum terminator.
OutTerminator   = "";
replytimeout = 200;
## Setting a small readtimeout means that we can get data without needing a terminator
readtimeout  = 100;
extrainput   = Ignore;

#STX = "\x02"
#ETX = "\x03"
#EOT = "\x04"
#ENQ = "\x05"
#ACK = "\x06"

## Read value
## \code
## send: [EOT](GAD)(GAD)(LAD)(LAD)(CHAN)(C1)(C2)[ENQ]
## reply: [STX](CHAN)(C1)(C2)<DATA>[ETX](BCC)
## \endcode
## - $1 = GAD
## - $2 = LAD
## - $3 = command mnemonic
#############################################################################
read { InTerminator = "\x03"; out "\x04\$1\$1\$2\$2\$3\x05"; in "\x02\$3%f"; }

## Read value, but in hex
readhex { InTerminator = "\x03"; out "\x04\$1\$1\$2\$2\$3\x05"; in "\x02\$3>%x"; }

## NOTE: we rely on readtimeout for the in commands. 
## Could use maxInput, but that screws up record initialisation (once inTerminator is set it can't be overwritten in the \@init handler)
##
## Write value
## \code
## send: [EOT](GAD)(GAD)(LAD)(LAD)[STX](CHAN)(C1)(C2)<DATA>[ETX](BCC)
## reply: [ACK] or [NAK], discarded as no terminator
## \endcode
## - $1 = GAD
## - $2 = LAD
## - $3 = command mnemonic
## - $4 = device prefix, \$(P)\$(Q)
#############################################################################
write {  InTerminator = ""; out "\x04\$1\$1\$2\$2\x02\$3%f\x03%6<xor>"; in "\x06"; @init{ read; }; @mismatch{ in "%(\$4:ERR.PROC)r"; }; }

## Write a value in int rather than float
writeint {  InTerminator = ""; out "\x04\$1\$1\$2\$2\x02\$3%i\x03%6<xor>"; in "\x06"; @init{ read; }; @mismatch{ in "%(\$4:ERR.PROC)r"; }; }
